#version 460

#extension GL_GOOGLE_include_directive : enable

layout(set = 0, binding = 0) uniform sampler2D          input_image;
layout(set = 0, binding = 1) uniform writeonly image2D  result;

#include <gpu_cpu_constants.h>
layout (local_size_x = PBRLIB_WORK_GROUP_SIZE, local_size_y = PBRLIB_WORK_GROUP_SIZE) in;

float rgb2luma(vec3 rgb)
{
    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));
}

void main()
{
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    
    vec3    center_color    = texelFetch(input_image, pixel_coord, 0).rgb;
    float   luma_center     = rgb2luma(center_color);

    float luma_down     = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(0, -1)).rgb);
    float luma_up       = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(0, 1)).rgb);
    float luma_left     = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(-1, 0)).rgb);
    float luma_right    = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(1, 0)).rgb);

    float luma_min = min(luma_center, min(min(luma_down, luma_up), min(luma_left, luma_right)));
    float luma_max = max(luma_center, max(max(luma_down, luma_up), max(luma_left, luma_right)));

    float luma_range = luma_max - luma_min;
    
    const float edge_threshold_min = 0.0312;
    const float edge_threshold_max = 0.125;
    if (luma_range < max(edge_threshold_min, edge_threshold_max * luma_max)) {
        imageStore(result, pixel_coord, vec4(center_color, 1.0));
        // imageStore(result, pixel_coord, vec4(vec3(0), 1.0));
        return ;
    }

    float luma_down_left    = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(-1, -1)).rgb);
    float luma_up_right     = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(1, 1)).rgb);
    float luma_up_left      = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(-1, 1)).rgb);
    float luma_down_right   = rgb2luma(texelFetchOffset(input_image, pixel_coord, 0, ivec2(1, -1)).rgb);

    float luma_down_up      = luma_down + luma_up;
    float luma_left_right   = luma_left + luma_right;

    float luma_left_corners     = luma_down_left + luma_up_left;
    float luma_down_corners     = luma_down_left + luma_down_right;
    float luma_right_corners    = luma_down_right + luma_up_right;
    float luma_up_corners       = luma_up_left + luma_up_right;

    float edge_horizontal = 
            abs(-2.0 * luma_left + luma_left_corners) 
        +   2.0 * abs(-2.0 * luma_center + luma_down_up) 
        +   abs(-2.0 * luma_right + luma_right_corners);

    float edge_vertical = 
            abs(-2.0 * luma_up + luma_up_corners)
        +   2.0 * abs(-2.0 * luma_center + luma_left_right)
        +   abs(-2.0 * luma_down + luma_down_corners);

    bool is_horizontal = edge_horizontal >= edge_vertical;

    float luma_1 = is_horizontal ? luma_down : luma_left;
    float luma_2 = is_horizontal ? luma_up : luma_right;

    float gradient_1 = luma_1 - luma_center;
    float gradient_2 = luma_2 - luma_center;

    bool is_1_steepest = abs(gradient_1) >= abs(gradient_2);

    float gradient_scaled = 0.25 * max(abs(gradient_1), abs(gradient_2));

    /// @todo send from push constant
    vec2 img_size       = vec2(imageSize(result));
    vec2 inv_img_size   = vec2(1.0) / img_size;

    float step_length           = is_horizontal ? inv_img_size.y : inv_img_size.x;
    float luma_local_avarage    = 0.0;
    if (is_1_steepest)
    {
        step_length         = -step_length;
        luma_local_avarage  = 0.5 * (luma_1 + luma_center);
    }
    else 
        luma_local_avarage = 0.5 * (luma_2 + luma_center);

    if (is_horizontal)
        pixel_coord.y += int(round(img_size.y * step_length * 0.5));
    else
        pixel_coord.x += int(round(img_size.x * step_length * 0.5));

    imageStore(result, pixel_coord, vec4(vec3(gradient_scaled) * 20.0, 1.0));
}