#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include <gpu_cpu_constants.h>
layout (local_size_x = PBRLIB_WORK_GROUP_SIZE, local_size_y = PBRLIB_WORK_GROUP_SIZE) in;

#include <generation.glsl>

#define PBRLIB_GBUFFER_GENERATOR_EXPORTS_SET_ID 0
#include <gbuffer_generator/exports.glsl>
#include <gbuffer_generator/packing.glsl>

#define PBRLIB_MATERIAL_MANAGER_SET_ID 2
#include <material_manager/exports.glsl>

layout(set = 1, binding = 0, r16f) uniform writeonly image2D result;

layout(set = 1, binding = 1) uniform Params
{
    float   radius;
    uint    sample_count;
    vec2    noise_scale;
};

layout(set = 1, binding = 2) uniform Samples
{
    vec4 samples[64];
};

layout(push_constant) uniform PerFrameData
{
    mat4 projection_view;
};

vec2 getUV(vec3 pos)
{
    vec4 ndc = projection_view * vec4(pos, 1);
    ndc.xyz /= ndc.w;
    return ndc.xy * 0.5 + 0.5;
}

vec3 getGBufferPosition(vec2 screen_uv)
{
    vec3 pos    = vec3(0);
    vec2 uv     = vec2(0);

    unpackPosUv(texture(gbuffer_pos_uv, screen_uv), pos, uv);

    return pos;
}

vec3 getNormal(vec2 screen_uv, vec2 geometry_uv)
{
    uint mat_index  = texture(gbuffer_material_index, screen_uv).r;
    uint img_index  = materials[mat_index].normal_map;

    return texture(materials_images[img_index], geometry_uv).xyz * 2.0 - 1.0;
}

float calcOcclution(vec3 pos, mat3 tbn, float depth)
{
    float occlusion = 0.0;

    const float bias = 0.03;

    for (uint i = 0; i < sample_count; ++i)
    {
        vec3 sample_pos = tbn * samples[i].xyz;
        sample_pos = pos + sample_pos * radius;

        vec2 sample_uv = getUV(sample_pos);

        float sample_depth  = getGBufferPosition(sample_uv).z;
        float range_check   = smoothstep(0.0, 1.0, radius / abs(pos.z - sample_depth));

        occlusion += (sample_depth >= sample_pos.z + bias ? 1.0 : 0.0) * range_check;  
    }

    return 1.0 - (occlusion / float(sample_count));
}

void main()
{
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);

    vec2 screen_uv = vec2(gl_GlobalInvocationID) / vec2(imageSize(result));

    vec3 pos    = vec3(0);
    vec2 uv     = vec2(0);

    unpackPosUv(texture(gbuffer_pos_uv, screen_uv), pos, uv);

    vec3 normal             = getNormal(screen_uv, uv);
    vec3 random_direction   = randomVec(pos);

    vec3 tangent = normalize(random_direction - normal * dot(random_direction, normal));

    mat3 tbn = mat3(
        tangent,
        cross(normal, tangent),
        normal
    );

    float depth = texture(gbuffer_depth, screen_uv).r;

    imageStore(result, pixel_coord, vec4(vec3(calcOcclution(pos, tbn, depth)), 1.0));
}